---
title: "RNA-seq low level EDA"
output:
  html_document:
  toc: true
---

# Goals of this workshop

* Low-level EDA (exploratory data analysis) of RNA-seq
* Examine biases affecting paired-end RNA-seq fragments

We will **not** cover, but you can read about elsewhere:

* Counting RNA-seq reads/fragments in genes
  * Using, e.g. [featureCounts](http://bioinf.wehi.edu.au/featureCounts/), 
    [htseq](http://www-huber.embl.de/HTSeq/doc/overview.html), 
    or [summarizeOverlaps](http://bioconductor.org/packages/GenomicAlignments)
  * Or [tximport](http://bioconductor.org/packages/tximport) following ultra-fast 
    quantification software such as [Sailfish](http://www.cs.cmu.edu/~ckingsf/software/sailfish/), 
    [Salmon](https://combine-lab.github.io/salmon/), or
    [kallisto](https://pachterlab.github.io/kallisto/)
* [Basic differential expression analysis workflow](http://www.bioconductor.org/help/workflows/rnaseqGene/)

# Gene annotation

We start by looking at two genes, USF2 and CHPF. Let's obtain some information on these genes from the *Homo.sapiens* package. We will pull out the 
transcript ID and name that go along with the gene symbols.

```{r}
library(Homo.sapiens)
columns(Homo.sapiens)
g <- list()
g[["USF2"]] <- select(Homo.sapiens, "USF2", c("TXID","TXNAME"), "SYMBOL")
g[["CHPF"]] <- select(Homo.sapiens, "CHPF", c("TXID","TXNAME"), "SYMBOL")
g
```

We can use a *TxDb* object to get the exons for the transcripts
of these two genes. The *exonsBy* function returns a *GRangesList*
object, and by specifying `by="tx"`, within this *GRangesList* 
we can find the GRanges for each exon of every transcript.
In `ebt` we have the exons of every transcript, labelled by
transcript ID. We then use the information from the previous
chunk to pull out the transcripts of USF2 and CHPF:

```{r}
library(TxDb.Hsapiens.UCSC.hg19.knownGene)
txdb <- TxDb.Hsapiens.UCSC.hg19.knownGene
ebt <- exonsBy(txdb, by="tx")
head(names(ebt))
usf2 <- ebt[ g[["USF2"]]$TXID ]
chpf <- ebt[ g[["CHPF"]]$TXID ]
```

We can take a look at these:

```{r}
usf2
chpf
```

If we ask about the `width` of the exons, we get an
*IntegerList*. If we follow that command with `sum`, 
we get the length of each transcript.

```{r}
width(usf2)
sum(width(usf2))
```

It will be useful to calculate the total range of the 
exons of the transcript of each gene:

```{r}
usf2.r <- range(unlist(usf2))
chpf.r <- range(unlist(chpf))
```

# Plotting gene models

Let's now visualize the exons of the transcripts using base R graphics.
First, let's write a line of code that draws the exons
of a single transcript of USF2:

```{r}
library(rafalib)
bigpar()
lens <- length(usf2)
nullplot(start(usf2.r),end(usf2.r),0,2)
segments(start(usf2[[1]]), rep(1,lens[1]), 
           end(usf2[[1]]), rep(1,lens[1]), lwd=3)
```

Now, to avoid repeating this code over and over for each
gene, let's write a general function for drawing the 
exons of each transcript of a gene, 
contained in a `GRangeList` x.

```{r}
plotGRangesList <- function(x,name="") {
  r <- range(unlist(range(x)))
  nullplot(start(r),end(r),0.5,length(x)+0.5,
           main=name,xlab=seqnames(x[[1]][1]))
  lens <- elementNROWS(x)
  for (i in seq_along(x)) {
    segments(start(x[[i]]), rep(i,lens[i]), 
             end(x[[i]]), rep(i,lens[i]), lwd=3)
  }
}
plotGRangesList(usf2, "USF2")
plotGRangesList(chpf, "CHPF")
```

# Reading in alignments

We have provided four BAM files for use in this workshop, so that we can 
explore how real RNA-seq fragments look using Bioconductor.
These four files are associated with GEUVADIS RNA-seq samples, 
aligned using [STAR](https://github.com/alexdobin/STAR) read aligner
version 2.5.0, aligning to the hg19 genome packaged by Illumina iGenomes.
The BAM files contain just a subset of the total number of paired-end reads,
to limit the disk space required for this workshop. The files contain
only the reads that overlap the genes USF2 and CHPF. Full details about
the experiments can be found by searching using the ERR ID on the 
[ENA](http://www.ebi.ac.uk/ena) website.

```{r}
dir <- system.file("extdata", package="bioc2016eda")
dir <- "inst/extdata"
samples <- read.csv(file.path(dir,"samples.csv"))
samples
```

We create a vector that points to these files on disk.

```{r}
library(GenomicAlignments)
bamfiles <- file.path(dir,paste0(samples$run,".bam"))
file.exists(bamfiles)
```

We did not sort or include an index for these BAM files, 
so first we must sort and index them. Normally,
you would sort and index these outside of R
using, e.g. [samtools](http://www.htslib.org/).

```{r}
for (i in seq_along(bamfiles)) {
  sortBam(bamfiles[i], destination=file.path(dir,paste0(samples$run[i],"_sort")))
  indexBam(file.path(dir,paste0(samples$run[i],"_sort.bam")))
}
bamfiles <- file.path(dir,paste0(samples$run,"_sort.bam"))
file.exists(bamfiles)
```

Now we can read in some paired alignments for the first BAM files, 
specifically those alignments that cover USF2.
We need to remove some of the `seqnames` from the
`usf2.r` ranges, as these do not exist in the BAM header.

```{r}
usf2.r <- keepStandardChromosomes(usf2.r)
gap <- readGAlignmentPairs(bamfiles[1], 
                           param=ScanBamParam(which=usf2.r))
gap
```

# Computing genomic coverage

It's helpful to be able to quickly visualize these alignments,
and one such summary visualization is to see where the reads 
fall on the genome. This plot can be made using the `summary`
function:

```{r}
cov <- coverage(gap)
cov.genome <- as.integer(cov[usf2.r][["chr19"]])
pos.genome <- seq(from=start(usf2.r),to=end(usf2.r))
plot(pos.genome, cov.genome, xlab="position (genome)", ylab="coverage")
```

# Find compatible overlaps

The function `findCompatibleOverlaps` can be used to do just that:
find which paired alignments are compatible with which transcripts.
"Compatible" in this case means that the splicing must be compatible:
the read junctions must align exactly with the introns of the transcript.
For more details, see `vignette("OverlapEncodings")`.

The returned object is of the class `Hits`, and can be interrogated
with `queryHits` and `subjectHits`. Transcripts 2 and 3 have the most
compatible alignments, though these are also the longest transcripts.

```{r}
fco <- findCompatibleOverlaps(gap, usf2)
fco
countSubjectHits(fco)
```

Note that elements of the query (paired alignments) can be compatible with 
multiple elements in the subject (transcripts). 
We may therefore want to categorize the paired alignments into *equivalence classes*, 
defined by the set of transcripts that the alignments are compatible with.
For more on the idea of equivalence classes see, 
e.g. the [Sailfish paper](http://www.ncbi.nlm.nih.gov/pubmed/24752080).

Here we will rename each paired alignment using a 1 or 0
if it is or is not comptabile with a transcript.
So `1-1-0-0-1` means that a paired alignment is compatible
with transcripts 1, 2, and 5.

```{r}
tab <- table(queryHits(fco), subjectHits(fco))
tab <- as.matrix(tab)
frags <- apply(tab, 1, paste, collapse="-")
frags[1]
```

We can then tabulate the paired alignments using their new
names. Note that we have the same number of alignments
this way as if we count the unique number of query hits.

```{r}
table(frags)
sum(table(frags))
length(unique(queryHits(fco)))
```

We can see by scanning the table that many reads are
not compatible with transcript 1, 4, or 5.

# Map to transcripts

Another useful operation is to map from genomic coordinates to 
transcript coordinates. To do this, we have to map 
the start and end of each fragment separately, 
because `mapToTranscripts` does not work on
*GAlignmentPairs*. Furthermore, from the help page,
"A successful mapping occurs when `x` is 
completely within the `transcripts` range".
So we will break apart each paired alignement that is
compatible with transcript 3 into a start position and
an end position, map these positions to transcript 
coordinates, then rebuild the fragment afterward.


```{r}
idx <- queryHits(fco)[subjectHits(fco) == 3]
gr <- as(gap[idx],"GRanges")
strand(gr) <- "*"
m2tx.start <- mapToTranscripts(resize(gr, width=1), 
                               usf2[3], ignore.strand=TRUE)
m2tx.start
```

```{r}
m2tx.end <- mapToTranscripts(resize(gr, width=1, fix="end"), 
                             usf2[3], ignore.strand=TRUE)
common <- intersect(m2tx.start$xHits, m2tx.end$xHits)
m2tx <- GRanges(rep("66828"), 
                IRanges(start(m2tx.start[m2tx.start$xHits %in% common]),
                        start(m2tx.end[m2tx.end$xHits %in% common])))
```

We can then compute transcript coverage:

```{r}
cov.tx <- coverage(m2tx)
plot(as.integer(cov.tx[[1]]), xlab="position (tx)", 
     ylab="coverage", main=names(usf2)[3])
```

# Fragment length distribution

```{r}
hist(width(m2tx))
```

# Fragment start and length plot

This plot is shown in Figure 6 in Evans, S.N., Hower, V., and Pachter, L. [Coverage statistics for sequence census methods](http://bmcbioinformatics.biomedcentral.com/articles/10.1186/1471-2105-11-430).

# Common sequences at read starts

# Fragment sequence features

# Other QA software

* ShortRead for quality assessment
* FASTQC and Multiqc





